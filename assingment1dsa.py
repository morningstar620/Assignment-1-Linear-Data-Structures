# -*- coding: utf-8 -*-
"""assingment1DSA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WZU9qGztqKXVE13Z8SDs7uM71_xBU1Ff
"""

#Q1. Write a program to find all pairs of an integer array whose sum is equal to a given number?

def find_pairs(arr, target):
    pairs = []
    seen = set()

    for num in arr:
        complement = target - num
        if complement in seen:
            pairs.append((num, complement))
        seen.add(num)

    return pairs

arr = list(map(int, input("Enter an integer array (space-separated): ").split()))
target = int(input("Enter the target sum: "))
result = find_pairs(arr, target)
print("Pairs:", result)

#Q2. Write a program to reverse an array in place? In place means you cannot create a new array. You have to update the original array.

def reverse_array(arr):
    start = 0
    end = len(arr) - 1

    while start < end:
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

arr = list(map(int, input("Enter an integer array (space-separated): ").split()))
reverse_array(arr)
print("Reversed Array:", arr)

#Q3. Write a program to check if two strings are a rotation of each other?

def are_rotations(str1, str2):
    if len(str1) != len(str2):
        return False

    temp = str1 + str1
    if str2 in temp:
        return True
    else:
        return False

str1 = input("Enter the first string: ")
str2 = input("Enter the second string: ")
result = are_rotations(str1, str2)
print("Are they rotations of each other?", result)

#Q4. Write a program to print the first non-repeated character from a string?

def first_non_repeated_char(s):
    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    for char in s:
        if char_count[char] == 1:
            return char
    return None

input_str = input("Enter a string: ")
result = first_non_repeated_char(input_str)
print("First non-repeated character:", result)

#Q5. Read about the Tower of Hanoi algorithm. Write a program to implement it.

def tower_of_hanoi(n, source, auxiliary, target):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
        return
    tower_of_hanoi(n - 1, source, target, auxiliary)
    print(f"Move disk {n} from {source} to {target}")
    tower_of_hanoi(n - 1, auxiliary, source, target)

num_disks = int(input("Enter the number of disks: "))
tower_of_hanoi(num_disks, 'A', 'B', 'C')

#Q6.Read about infix, prefix, and postfix expressions. Write a program to convert postfix to prefix expression.

def postfix_to_prefix(expression):
    stack = []
    operators = set(['+', '-', '*', '/'])

    for token in expression:
        if token not in operators:
            stack.append(token)
        else:
            operand2 = stack.pop()
            operand1 = stack.pop()
            prefix = token + operand1 + operand2
            stack.append(prefix)

    return stack[0]

postfix_expression = input("Enter a postfix expression: ")
prefix_expression = postfix_to_prefix(postfix_expression)
print("Prefix expression:", prefix_expression)

#Q7. Write a program to convert prefix expression to infix expression.

def prefix_to_infix(expression):
    stack = []
    operators = set(['+', '-', '*', '/'])

    for token in reversed(expression):
        if token not in operators:
            stack.append(token)
        else:
            operand1 = stack.pop()
            operand2 = stack.pop()
            infix = "(" + operand1 + token + operand2 + ")"
            stack.append(infix)

    return stack[0]

prefix_expression = input("Enter a prefix expression: ")
infix_expression = prefix_to_infix(prefix_expression)
print("Infix expression:", infix_expression)

#Q8. Write a program to check if all the brackets are closed in a given code snippet.

def check_brackets(code):
    stack = []

    for char in code:
        if char in "({[":
            stack.append(char)
        elif char in ")}]":
            if not stack:
                return False
            top = stack.pop()
            if (char == ')' and top != '(') or \
               (char == '}' and top != '{') or \
               (char == ']' and top != '['):
                return False

    return len(stack) == 0

code_snippet = input("Enter a code snippet: ")
result = check_brackets(code_snippet)
if result:
    print("All brackets are closed properly.")
else:
    print("Brackets are not closed properly.")

#Q9. Write a program to reverse a stack.

def reverse_stack(stack):
    if not stack:
        return
    temp = stack.pop()
    reverse_stack(stack)
    insert_at_bottom(stack, temp)

def insert_at_bottom(stack, item):
    if not stack:
        stack.append(item)
        return
    temp = stack.pop()
    insert_at_bottom(stack, item)
    stack.append(temp)

stack = list(map(int, input("Enter elements of the stack (space-separated): ").split()))
reverse_stack(stack)
print("Reversed stack:", stack)

#Q10. Write a program to find the smallest number using a stack.

def find_smallest_number(stack):
    if not stack:
        return None
    min_num = stack.pop()
    while stack:
        num = stack.pop()
        min_num = min(min_num, num)
    return min_num

stack = list(map(int, input("Enter elements of the stack (space-separated): ").split()))
smallest_number = find_smallest_number(stack)
if smallest_number is not None:
    print("Smallest number in the stack:", smallest_number)
else:
    print("Stack is empty.")